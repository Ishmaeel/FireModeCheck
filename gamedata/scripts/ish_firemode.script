-- FireModeCheck - Nitpicker's Modpack
-- Last modified: 2021.08.05
firing_mode_descriptions = {[1] = "Single", [2] = "Burst", [3] = "Burst", [-1] = "Full-Auto"}

user_modes = {"firemode_handler_basic_check", "firemode_handler_dual_key_check", "firemode_handler_single_key_check"}

_user_mode = user_modes[3]
_mute_switch = true
_tap_count = 0

local k_PREV = key_bindings.kWPN_FIREMODE_PREV
local k_NEXT = key_bindings.kWPN_FIREMODE_NEXT

function on_game_start()
    RegisterScriptCallback("on_key_press", ishy_on_key_press)

    if void_fmode_sound then
        void_fmode_sound.is_weapon_ready = is_weapon_really_ready -- Compatibility with General Fire Mode Switcher Sound (GFMSS)
    end
end

function ishy_on_key_press(key)
    local bind = dik_to_bind(key)

    if bind == k_PREV or bind == k_NEXT then
        _mute_switch = true -- Make sure GFMSS does not play audio unless we actually allow mode switch.
        _last_bind = bind

        handler = this[_user_mode]
        if handler then
            handler()
        end
    end
end

-- Do nothing. Just report the new firing mode after letting the switch go through.
function firemode_handler_basic_check()
    _mute_switch = false
    show_firemode()
end

-- NEXT key works normally. PREV key blocks the switch and just reports firing mode.
function firemode_handler_dual_key_check()
    if _last_bind == k_PREV then
        level.disable_input()
    end

    _mute_switch = false
    show_firemode()
end

-- Both keys function in the same way: Single tap: check only. Double tap, switch to next/prev mode.
function firemode_handler_single_key_check()
    _tap_count = (_tap_count or 0) + 1

    if _tap_count > 1 then
        _tap_count = 0
        show_firemode()
    else
        level.disable_input()
        show_firemode()
        reset_taps()
        _mute_switch = false
    end
end

function show_firemode()
    CreateTimeEvent("firemode_check", "show_firemode_delayed", 0, show_firemode_delayed)
end

function show_firemode_delayed()
    level.enable_input()
    local current_mode = get_fire_mode()
    local mode_description = firing_mode_descriptions[current_mode]
    show_message(mode_description)
    return true
end

function reset_taps()
    CreateTimeEvent("firemode_check", "reset_taps_delayed", 0.5, reset_taps_delayed)
end

function reset_taps_delayed()
    _tap_count = 0
    _mute_switch = true
    return true
end

function get_fire_mode()
    local weapon = db.actor:active_item()
    if weapon == nil or not IsWeapon(weapon) or IsItem("fake_ammo_wpn", nil, weapon) or not has_multiple_fire_modes(weapon:section()) then
        return
    end

    local cWeapon = weapon:cast_Weapon()
    return (cWeapon and cWeapon:GetFireMode()) or 0
end

function has_multiple_fire_modes(section)
    local fire_modes = parse_list(ini_sys, section, "fire_modes")

    if fire_modes and table.getn(fire_modes) > 1 then
        return true
    end

    return false
end

function is_weapon_really_ready(wpn)
    if _mute_switch then
        return false
    end

    local state = wpn:get_state()
    return state == 0 -- eIdle
end

function show_message(message, ...)
    if message and actor_menu then
        actor_menu.set_msg(2, string.format(message, ...), 4)
    end
end
