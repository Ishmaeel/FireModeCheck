-- FireModeCheck Alpha by Ishmaeel.
-- Last modified: 2021.08.05
firing_mode_descriptions = {[1] = "Single", [2] = "Burst", [3] = "Burst", [-1] = "Full-Auto"}

user_modes = {"firemode_handler_basic_check", "firemode_handler_dual_key_check", "firemode_handler_single_key_check"}

_user_mode = user_modes[3]
_tap_count = nil
_mute_switch = nil

local k_PREV = key_bindings.kWPN_FIREMODE_PREV
local k_NEXT = key_bindings.kWPN_FIREMODE_NEXT

function on_game_start()
    RegisterScriptCallback("on_key_press", ishy_on_key_press)
    take_hostages()
end

function ishy_on_key_press(key)
    local bind = dik_to_bind(key)

    if bind == k_PREV or bind == k_NEXT then
        _mute_switch = true -- Make sure GFMSS does not play audio unless we actually allow mode switch.
        _last_bind = bind

        handler = this[_user_mode]
        if handler then
            handler()
        end

        if not _mute_switch then
            on_key_press_relay(key)
        end
    end
end

-- Do nothing. Just report the new firing mode after letting the switch go through.
function firemode_handler_basic_check()
    _mute_switch = false
    show_firemode()
end

-- NEXT key works normally. PREV key blocks the switch and just reports firing mode.
function firemode_handler_dual_key_check()
    if _last_bind == k_PREV then
        level.disable_input()
    else
        _mute_switch = false
    end

    show_firemode()
end

-- Both keys function in the same way: Single tap: check only. Double tap, switch to next/prev mode.
function firemode_handler_single_key_check()
    _tap_count = (_tap_count or 0) + 1

    if _tap_count > 1 then
        _tap_count = 0
        _mute_switch = false
    else
        level.disable_input()
        reset_taps()
    end

    show_firemode()
end

function show_firemode()
    CreateTimeEvent("firemode_check", "show_firemode_delayed", 0, show_firemode_delayed)
end

function show_firemode_delayed()
    level.enable_input()
    local current_mode = get_fire_mode()
    local mode_description = firing_mode_descriptions[current_mode]
    show_message(mode_description)
    return true
end

function reset_taps()
    CreateTimeEvent("firemode_check", "reset_taps_delayed", 0.5, reset_taps_delayed)
end

function reset_taps_delayed()
    _tap_count = 0
    return true
end

function get_fire_mode()
    local weapon = db.actor:active_item()
    if weapon == nil or not IsWeapon(weapon) or IsItem("fake_ammo_wpn", nil, weapon) or not has_multiple_fire_modes(weapon:section()) then
        return
    end

    local cWeapon = weapon:cast_Weapon()
    return (cWeapon and cWeapon:GetFireMode()) or 0
end

function has_multiple_fire_modes(section)
    local fire_modes = parse_list(ini_sys, section, "fire_modes")

    if fire_modes and table.getn(fire_modes) > 1 then
        return true
    end

    return false
end

function show_message(message, ...)
    if message and actor_menu then
        actor_menu.set_msg(2, string.format(message, ...), 4)
    end
end

--------------------------------------------------------------------------------------------------------------
------ Compatibility section for General Fire Mode Switcher Sound (GFMSS) by TheVoidPancake + HarukaSai ------
------      https://www.moddb.com/mods/stalker-anomaly/addons/general-fire-mode-switcher-sound           -----
--------------------------------------------------------------------------------------------------------------

function take_hostages()
    -- if GFMSS is installed, monkey patch its key press handler and take it hostage.
    if void_fmode_sound and void_fmode_sound.on_key_press then
        on_key_press_relay = void_fmode_sound.on_key_press -- take this and wait for my signal!
        void_fmode_sound.on_key_press = on_key_press_gatekeeper -- not a peep unless I say so!
    end
end

function on_key_press_relay()
    -- just a placeholder. it will be replaced with GFMSS on_key_press.
end

function on_key_press_gatekeeper()
    -- just a void function. it will effectively disable GFMSS on_key_press.
end
