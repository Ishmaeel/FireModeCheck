-- FireModeCheck - Nitpicker's Modpack
-- Last modified: 2021.08.05
firing_mode_descriptions = {[1] = "Single", [2] = "Burst", [3] = "Burst", [-1] = "Full-Auto"}

mode_info = {user_mode = "firemode_handler_basic_check", mute = true}

local k_PREV = key_bindings.kWPN_FIREMODE_PREV
local k_NEXT = key_bindings.kWPN_FIREMODE_NEXT

function on_game_start()
    RegisterScriptCallback("on_key_press", ishy_on_key_press)

    mode_info.user_mode = "firemode_handler_dual_key_check"
    mode_info.user_mode = "firemode_handler_single_key_check"

    if void_fmode_sound then
        void_fmode_sound.is_weapon_ready = is_weapon_really_ready -- Compatibility with General Fire Mode Switcher Sound (GFMSS)
    end
end

function ishy_on_key_press(key)
    local bind = dik_to_bind(key)

    if bind == k_PREV or bind == k_NEXT then
        mode_info.mute = true -- Make sure GFMSS does not play audio unless we actually allow mode switch.
        mode_info.key = key
        mode_info.bind = bind

        handler = this[mode_info.user_mode]
        if handler then
            handler()
        end
    end
end

-- Do nothing. Just report the new firing mode after letting the switch go through.
function firemode_handler_basic_check()
    mode_info.mute = false
    show_firemode()
end

-- NEXT key works normally. PREV key blocks the switch and just reports firing mode.
function firemode_handler_dual_key_check()
    if mode_info.bind == k_PREV then
        level.disable_input()
    end

    mode_info.mute = false
    show_firemode()
end

-- Both keys function in the same way: Single tap: check only. Double tap, switch to next/prev mode.
function firemode_handler_single_key_check()
    mode_info.tap = (mode_info.tap or 0) + 1

    if mode_info.tap > 1 then
        mode_info.tap = 0
        show_firemode()
    else
        level.disable_input()
        show_firemode()
        reset_taps()
        mode_info.mute = false
    end
end

function show_firemode()
    CreateTimeEvent("firemode_check", "show_firemode_delayed", 0, show_firemode_delayed)
end

function show_firemode_delayed()
    level.enable_input()
    local current_mode = get_fire_mode()
    local mode_description = firing_mode_descriptions[current_mode]
    show_message(mode_description)
    return true
end

function reset_taps()
    CreateTimeEvent("firemode_check", "reset_taps_delayed", 0.5, reset_taps_delayed)
end

function reset_taps_delayed()
    mode_info.tap = 0
    mode_info.mute = true
    return true
end

function get_fire_mode()
    local weapon = db.actor:active_item()
    if weapon == nil or not IsWeapon(weapon) or IsItem("fake_ammo_wpn", nil, weapon) or not has_multiple_fire_modes(weapon:section()) then
        return
    end

    local cWeapon = weapon:cast_Weapon()
    return (cWeapon and cWeapon:GetFireMode()) or 0
end

function has_multiple_fire_modes(section)
    local fire_modes = parse_list(ini_sys, section, "fire_modes")

    if fire_modes and table.getn(fire_modes) > 1 then
        return true
    end

    return false
end

function is_weapon_really_ready(wpn)
    d.info("Mute: %s", mode_info.mute)
    if mode_info.mute then
        return false
    end

    local state = wpn:get_state()
    return state == 0 -- eIdle
end

function show_message(message, ...)
    if message and actor_menu then
        actor_menu.set_msg(2, string.format(message, ...), 4)
    end
end
